## 张翔宇周总结

### 一、Python方面

### 1.模块

模块类似java中的类，在另一个模块中用关键词import之后，就可以调用被导入模块的方法和变量了。

### 2.高级数据类型

#### （1）列表

列表类似于其他编程语言中的数组，用于存储一系列类型相同的元素，是python中使用最频繁的高级数据类型。

用法：将数据类型相同的元素值放在[]内，每一个元素值用逗号分割。（也能存储数据类型不相同的值，但是一般不常用）

常用操作：

index：返回具体元素值对应的下标索引

append：在列表末尾追加数据

insert:在列表指定位置插入元素

extend：将其他列表的元素合并到当前列表的末尾

remove：将指定元素值从列表中移除

pop:如果指定下标索引，则将下标索引对应的元素值弹出。不指定任何参数，则默认将最后一个元素弹出！

clear:将列表中所有元素值清空

len():统计列表中元素个数

count：统计指定元素在列表中出现次数

sort:对列表进行升序排列

sort(reverse=True):对列表进行降序排列

reverse：反转列表

for 变量 in 列表：对指定列表进行遍历操作

del关键字可以将指定变量从内存中删除。删除列表中的元素一般不使用del

#### （2）元组

元组：非常类似于列表，他是用来存储数据类型不同的元素值，用（）括起来，元素值用逗号分隔

常用操作：

index：返回指定元素在元组中的下标索引

count：统计某个元素在元组中出现次数

len():统计元组中元素值个数

元组的遍历方式和列表一致

#### （3）字典

字典类似于C语言中的结构体变量，通常用于描述一个对象的各项情况，字典中的每项数据是以键值对形式存在的。

常用操作：

取出字典中键对应的值：字典名称["键"]

增加字典中的数据项：字典名称["新增的键名"]=键值

修改字典中的数据项：字典名称["要修改的键名"]=要修改的元素值

删除字典中的数据项：pop(键名)

len():返回字典中键值对个数

update：合并字典，如果被合并的字典中有与原字典中重复的键值对，进行对原有键值对的覆盖

clear：清空字典

字典的遍历与列表和元组稍有不同

for  变量（表示键名） in 字典

#### （4）字符串

在python中表示字符串，使用双引号或单引号括住，都可表示。一般使用双引号

常用操作：

len()：统计字符串的长度

count：统计一个子串在原字符串中出现次数

index：返回一个子串在原字符串中第一次出现的下标索引，没有找到则会报错

isspace：判断字符串中是否存在空格或空白字符

isdecimal:判断字符串中是否存在数字

isdigit：判断字符串中是否存在数字或Unicode编码

isnumeric：判断字符串中是否存在数字或Unicode编码或汉字中的数字表示

startswith：判断原字符串是否是以这个字符串开头

endswith：判断原字符串是否是以这个字符串结尾

find：返回一个子串在原字符串中第一次出现的下标索引，没有找到则返回-1

replace：将指定字符串替换成相应的字符串，返回一个新串。实质上不会改变原字符串

strip：去除空白字符

split：对字符串进行拆分

join：合并字符串

### 二、算法方面

### 1.DFS

深度优先搜索的步骤分为 1.递归下去 2.回溯上来。顾名思义，深度优先，则是以深度为准则，先一条路走到底，直到达到目标。这里称之为递归下去。

否则既没有达到目标又无路可走了，那么则退回到上一步的状态，走其他路。这便是回溯上来。

### 2.BFS：

广度优先搜索较之深度优先搜索之不同在于，深度优先搜索旨在不管有多少条岔路，先一条路走到底，不成功就返回上一个路口然后就选择下一条岔路，而广度优先搜索旨在面临一个路口时，把所有的岔路口都记下来，然后选择其中一个进入，然后将它的分路情况记录下来，然后再返回来进入另外一个岔路，并重复这样的操作

### 3.区别：

#### （1）数据结构上的运用

DFS用递归的形式，用到了栈结构，先进后出。

BFS选取状态用队列的形式，先进先出。

#### （2）复杂度

DFS的复杂度与BFS的复杂度大体一致，不同之处在于遍历的方式与对于问题的解决出发点不同，DFS适合目标明确，而BFS适合大范围的寻找。

### 三、存在的问题

（1）Python进度紧张

（2）对DFS、BFS算法理解不够

### 四、改进

（1）努力赶python进度，争取高效快速跟完黑马

（2）提高刷题精度和算法理解程度。









