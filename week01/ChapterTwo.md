## ChapterTwo

### 1.插入排序

```c
void InsertionSort1(int a[],int n)
{
	for(int j=1;j<n;j++)
	{
		int key=a[j];
		int i=j-1;
		while(i>=0&&a[i]>key)
		{
			a[i+1]=a[i];
			i--;
		}
		a[i+1]=key;
	}
}
```

#### 思路：非常简单，像平时打扑克牌一样。每次将新的数字，从后往前依次对比，比它大的往后移动，直到出现比他小的位置，在其后的位置插入即可。

### 2.分治算法

#### 思路：大问题不好解决，将一个大问题分成多个小的、同种类型的问题。将小问题依次解决之后，大问题即可解决！

### 3.分治算法的排序应用——归并排序

```C
//合并
void Merge(int a[],int p,int q,int r)
{
	int n1=q-p+1;//左侧个数 
	int n2=r-q;//右侧个数 
	int L[n1+1];//开辟左侧辅助数组 
	int R[n2+1];//开辟右侧辅助数组
	//左侧辅助数组填充值 
	for(int i=0;i<n1;i++)
	{
		L[i]=a[p+i];
	}
	//右侧辅助数组填充值 
	for(int j=0;j<n2;j++)
	{
		R[j]=a[q+1+j];
	}
	//左侧数组最末的哨兵 
	L[n1]=999;//表示无穷
	//右侧数组最末的哨兵 
	R[n2]=999;//表示无穷 
	
	int i=0;//左侧数组指针 
	int j=0;//右侧数组指针
	//两侧进行归并，哪边所指的值小，将值小的数填进原数组，指针++；
	//当一侧走完的话，指针指向了末尾哨兵最大值，另一侧肯定都比哨兵小，所以剩下的就是将另一侧依次填充回原数组 
	for(int k=p;k<=r;k++)
	{
		if(L[i]<=R[j])
		{
			a[k]=L[i];
			i++; 
		}
		else
		{
			a[k]=R[j];
			j++;
		}
	}
	
}




//归并排序
/*
参数p和r表示排序数组的范围 
n个数进行划分，需要logN次
每次合并需要N
所以时间复杂度是NlogN 
*/ 
void MergeSort(int a[],int p,int r)
{
	if(p<r)
	{
		int q=(p+r)/2;//取中间位置 
		MergeSort(a,p,q);//左侧递归 
		MergeSort(a,q+1,r);//右侧递归 
		Merge(a,p,q,r);//两侧合并 
	} 
}
```

